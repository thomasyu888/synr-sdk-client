# Platform Repository Service
#
# Platform Repository Service - Sage Bionetworks Platform 
#
# The version of the OpenAPI document: develop-SNAPSHOT
# Contact: thomas.yu@sagebionetworks.org
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title EvaluationServices operations
#' @description synclient.EvaluationServices
#' @format An \code{R6Class} generator object
#' @field apiClient Handles the client-server communication.
#'
#' @section Methods:
#' \describe{
#' \strong{ CreateEvaluation } \emph{ Creates a new Evaluation. }
#' &#39;Creates a new Evaluation. The passed request body should contain the following fields:  &lt;ul&gt;  &lt;li&gt;name - Give your new Evaluation a name.&lt;/li&gt;  &lt;li&gt;contentSource - The ID of the parent Entity, such as a Folder or Project.&lt;/li&gt;  &lt;li&gt;status - The initial state of the Evaluation, an  &lt;a href&#x3D;\&quot;${org.sagebionetworks.evaluation.model.EvaluationStatus}\&quot;&gt;EvaluationStatus&lt;/a&gt;&lt;/li&gt;  &lt;/ul&gt;  &lt;p&gt;  &lt;b&gt;Note:&lt;/b&gt; The caller must be granted the &lt;a href&#x3D;\&quot;${org.sagebionetworks.repo.model.ACCESS_TYPE}\&quot;&gt;ACCESS_TYPE.CREATE&lt;/a&gt; on the contentSource Entity.  &lt;/p&gt; 
#'
#' \itemize{
#' \item \emph{ @param } evaluation \link{Evaluation}
#' \item \emph{ @returnType } \link{Evaluation} \cr
#'
#'
#' \item status code : 201 | Success
#'
#' \item return type : Evaluation 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CreateEvaluationRound } \emph{ Create Evaluation Round }
#' Create Evaluation Round
#'
#' \itemize{
#' \item \emph{ @param } eval.id character
#' \item \emph{ @param } evaluation.round \link{EvaluationRound}
#' \item \emph{ @returnType } \link{EvaluationRound} \cr
#'
#'
#' \item status code : 201 | Success
#'
#' \item return type : EvaluationRound 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CreateSubmission } \emph{ Creates a Submission and sends a submission notification email to the submitter&#39;s team members.  }
#' Creates a Submission and sends a submission notification email to the submitter&#39;s team members.  The passed request body should contain the following fields:  &lt;ul&gt;  &lt;li&gt;evaluationId - The ID of the Evaluation to which this Submission belongs.&lt;/li&gt;  &lt;li&gt;entityId - The ID of the Entity being submitted.&lt;/li&gt;  &lt;li&gt;versionNumber - The specific version of the Entity being submitted.&lt;/li&gt;  &lt;/ul&gt;  &lt;p&gt;  A Submission must be either a Team or an Individual submission.  A Team submission must include a Team ID in the teamId field and the request must include a submissionEligibilityHash request parameter.  A Team submission may also include a list of submission contributors. (The submitter is taken to be a contributor and need not be included in the list.) An individual submission must have a null teamId, a null or empty contributor list, and no submissionEligibilityHash parameter.  &lt;/p&gt;  &lt;p&gt;  &lt;b&gt;Note:&lt;/b&gt; The caller must be granted the &lt;a href&#x3D;\&quot;${org.sagebionetworks.repo.model.ACCESS_TYPE}\&quot;&gt;ACCESS_TYPE.SUBMIT&lt;/a&gt;.  &lt;/p&gt;  &lt;p&gt;  This call also creates an associated &lt;a href&#x3D;\&quot;${org.sagebionetworks.evaluation.model.SubmissionStatus}\&quot;&gt;SubmissionStatus&lt;/a&gt;, initialized with a SubmissionStatusEnum value of RECEIVED.  &lt;/p&gt; 
#'
#' \itemize{
#' \item \emph{ @param } challenge.endpoint character
#' \item \emph{ @param } etag character
#' \item \emph{ @param } notification.unsubscribe.endpoint character
#' \item \emph{ @param } submission.eligibility.hash character
#' \item \emph{ @param } submission.model \link{SubmissionModel}
#' \item \emph{ @returnType } \link{SubmissionModel} \cr
#'
#'
#' \item status code : 201 | Success
#'
#' \item return type : SubmissionModel 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ DeleteAcl } \emph{ This method is deprecated and should be removed from future versions of the API. }
#' This method is deprecated and should be removed from future versions of the API.  Deletes the ACL (access control list) of the specified evaluation. The user should have the proper &lt;a href&#x3D;\&quot;${org.sagebionetworks.evaluation.model.UserEvaluationPermissions}\&quot;&gt;permissions&lt;/a&gt; to delete the ACL. 
#'
#' \itemize{
#' \item \emph{ @param } eval.id character
#'
#'
#' \item status code : 204 | The resource was deleted
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ DeleteEvaluation } \emph{ Deletes an Evaluation. }
#' Deletes an Evaluation.  &lt;p&gt;  &lt;b&gt;Note:&lt;/b&gt; The caller must be granted the &lt;a href&#x3D;\&quot;${org.sagebionetworks.repo.model.ACCESS_TYPE}\&quot;&gt;ACCESS_TYPE.DELETE&lt;/a&gt; on the specified Evaluation.  &lt;/p&gt; 
#'
#' \itemize{
#' \item \emph{ @param } eval.id character
#'
#'
#' \item status code : 204 | The resource was deleted.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ DeleteEvaluationRound } \emph{ Delete Evaluation Round }
#' Delete Evaluation Round
#'
#' \itemize{
#' \item \emph{ @param } eval.id character
#' \item \emph{ @param } round.id character
#'
#'
#' \item status code : 204 | The resouce has been deleted
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ DeleteSubmission } \emph{ Deletes a Submission and its accompanying SubmissionStatus. }
#' Deletes a Submission and its accompanying SubmissionStatus.  &lt;b&gt;This service is intended to only be used by ChallengesInfrastructure service account.&lt;/b&gt;  &lt;p&gt;  &lt;b&gt;Note:&lt;/b&gt; The caller must be granted the &lt;a href&#x3D;\&quot;${org.sagebionetworks.repo.model.ACCESS_TYPE}\&quot;&gt;ACCESS_TYPE.DELETE_SUBMISSION&lt;/a&gt; on the specified Evaluation.  &lt;/p&gt; 
#'
#' \itemize{
#' \item \emph{ @param } sub.id character
#'
#'
#' \item status code : 204 | The resource has been deleted.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ FindEvaluation } \emph{ Finds an Evaluation by name. }
#' Finds an Evaluation by name. &lt;p&gt; &lt;b&gt;Note:&lt;/b&gt; The caller must be granted the &lt;a href&#x3D;\&quot;${org.sagebionetworks.repo.model.ACCESS_TYPE}\&quot;&gt;ACCESS_TYPE.READ&lt;/a&gt; on the specified Evaluation. &lt;/p&gt; 
#'
#' \itemize{
#' \item \emph{ @param } name character
#' \item \emph{ @returnType } \link{Evaluation} \cr
#'
#'
#' \item status code : 200 | Success
#'
#' \item return type : Evaluation 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetAcl } \emph{ Gets the access control list (ACL) governing the given evaluation. }
#' Gets the access control list (ACL) governing the given evaluation. The user should have the proper &lt;a href&#x3D;\&quot;${org.sagebionetworks.evaluation.model.UserEvaluationPermissions}\&quot;&gt;permissions&lt;/a&gt; to read the ACL. 
#'
#' \itemize{
#' \item \emph{ @param } eval.id character
#' \item \emph{ @returnType } \link{AccessControlList} \cr
#'
#'
#' \item status code : 200 | Success
#'
#' \item return type : AccessControlList 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetAllEvaluationRounds } \emph{ Get all rounds of an Evaluation }
#' Get all rounds of an Evaluation
#'
#' \itemize{
#' \item \emph{ @param } eval.id character
#' \item \emph{ @param } evaluation.round.list.request \link{EvaluationRoundListRequest}
#' \item \emph{ @returnType } \link{EvaluationRoundListResponse} \cr
#'
#'
#' \item status code : 200 | Success
#'
#' \item return type : EvaluationRoundListResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetAllSubmissionBundles } \emph{ Gets a collection of bundled Submissions and SubmissionStatuses to a given Evaluation. }
#' Gets a collection of bundled Submissions and SubmissionStatuses to a given Evaluation.  &lt;p&gt; &lt;b&gt;Note:&lt;/b&gt; The caller must be granted the &lt;a href&#x3D;\&quot;${org.sagebionetworks.repo.model.ACCESS_TYPE}\&quot;&gt;ACCESS_TYPE.READ_PRIVATE_SUBMISSION&lt;/a&gt; on the specified Evaluation. &lt;/p&gt; 
#'
#' \itemize{
#' \item \emph{ @param } eval.id character
#' \item \emph{ @param } limit integer
#' \item \emph{ @param } offset integer
#' \item \emph{ @param } status character
#' \item \emph{ @returnType } \link{PaginatedResultsOfSubmissionBundle} \cr
#'
#'
#' \item status code : 200 | Success
#'
#' \item return type : PaginatedResultsOfSubmissionBundle 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetAllSubmissionStatuses } \emph{ Gets a collection of SubmissionStatuses to a specified Evaluation. }
#' &#39;Gets a collection of SubmissionStatuses to a specified Evaluation.  &lt;p&gt;  &lt;b&gt;Note:&lt;/b&gt; The caller must be granted the &lt;a href&#x3D;\&quot;${org.sagebionetworks.repo.model.ACCESS_TYPE}\&quot;&gt;ACCESS_TYPE.READ&lt;/a&gt; on the specified Evaluation. Furthermore, the caller must be granted the &lt;a href&#x3D;\&quot;${org.sagebionetworks.repo.model.ACCESS_TYPE}\&quot;&gt;ACCESS_TYPE.READ_PRIVATE_SUBMISSION&lt;/a&gt; to see all data marked as \&quot;private\&quot; in the SubmissionStatuses.  &lt;/p&gt; 
#'
#' \itemize{
#' \item \emph{ @param } eval.id character
#' \item \emph{ @param } limit integer
#' \item \emph{ @param } offset integer
#' \item \emph{ @param } status character
#' \item \emph{ @returnType } \link{PaginatedResultsOfSubmissionStatus} \cr
#'
#'
#' \item status code : 200 | Success
#'
#' \item return type : PaginatedResultsOfSubmissionStatus 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetAllSubmissions } \emph{ Gets a collection of Submissions to a specified Evaluation. }
#' &#39;Gets a collection of Submissions to a specified Evaluation. &lt;p&gt; &lt;b&gt;Note:&lt;/b&gt; The caller must be granted the &lt;a href&#x3D;\&quot;${org.sagebionetworks.repo.model.ACCESS_TYPE}\&quot;&gt;ACCESS_TYPE.READ_PRIVATE_SUBMISSION&lt;/a&gt; on the specified Evaluation. &lt;/p&gt; 
#'
#' \itemize{
#' \item \emph{ @param } eval.id character
#' \item \emph{ @param } limit integer
#' \item \emph{ @param } offset integer
#' \item \emph{ @param } status character
#' \item \emph{ @returnType } \link{PaginatedResultsOfSubmission} \cr
#'
#'
#' \item status code : 200 | Success
#'
#' \item return type : PaginatedResultsOfSubmission 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetAvailableEvaluationsPaginated } \emph{ Gets a collection of Evaluations in which the user has SUBMIT permission, within a given range.  }
#' Gets a collection of Evaluations in which the user has SUBMIT permission, within a given range. &lt;p&gt; &lt;b&gt;Note:&lt;/b&gt; The response will contain only those Evaluations on which the caller must is granted the &lt;a href&#x3D;\&quot;${org.sagebionetworks.repo.model.ACCESS_TYPE}\&quot;&gt;ACCESS_TYPE.SUBMIT&lt;/a&gt; permission. &lt;/p&gt; 
#'
#' \itemize{
#' \item \emph{ @param } active.only character
#' \item \emph{ @param } evaluation.ids character
#' \item \emph{ @param } limit integer
#' \item \emph{ @param } offset integer
#' \item \emph{ @returnType } \link{PaginatedResultsOfEvaluation} \cr
#'
#'
#' \item status code : 200 | Success
#'
#' \item return type : PaginatedResultsOfEvaluation 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetEvaluation } \emph{ Gets an Evaluation. }
#' Gets an Evaluation.   &lt;p&gt;  &lt;b&gt;Note:&lt;/b&gt; The caller must be granted the &lt;a  href&#x3D;\&quot;${org.sagebionetworks.repo.model.ACCESS_TYPE}\&quot;  &gt;ACCESS_TYPE.READ&lt;/a&gt; on the specified Evaluation.  &lt;/p&gt; 
#'
#' \itemize{
#' \item \emph{ @param } eval.id character
#' \item \emph{ @returnType } \link{Evaluation} \cr
#'
#'
#' \item status code : 200 | Success
#'
#' \item return type : Evaluation 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetEvaluationRound } \emph{ Get Evaluation Round }
#' Get Evaluation Round
#'
#' \itemize{
#' \item \emph{ @param } eval.id character
#' \item \emph{ @param } round.id character
#' \item \emph{ @returnType } \link{EvaluationRound} \cr
#'
#'
#' \item status code : 200 | Success
#'
#' \item return type : EvaluationRound 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetEvaluationsByContentSourcePaginated } \emph{ Gets Evaluations tied to a project. }
#' Gets Evaluations tied to a project. &lt;b&gt;Note:&lt;/b&gt; The response will contain only those Evaluations on which the caller is granted the &lt;a href&#x3D;\&quot;${org.sagebionetworks.repo.model.ACCESS_TYPE}\&quot;&gt;ACCESS_TYPE.READ&lt;/a&gt; permission, unless specified otherwise with the accessType parameter. 
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @param } access.type \link{ACCESSTYPE}
#' \item \emph{ @param } active.only character
#' \item \emph{ @param } evaluation.ids character
#' \item \emph{ @param } limit integer
#' \item \emph{ @param } offset integer
#' \item \emph{ @returnType } \link{PaginatedResultsOfEvaluation} \cr
#'
#'
#' \item status code : 200 | Success
#'
#' \item return type : PaginatedResultsOfEvaluation 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetEvaluationsPaginated } \emph{ Gets a collection of Evaluations, within a given range. }
#' Gets a collection of Evaluations, within a given range.  &lt;p&gt;  &lt;b&gt;Note:&lt;/b&gt; The response will contain only those Evaluations on which the caller is  granted the &lt;a href&#x3D;\&quot;${org.sagebionetworks.repo.model.ACCESS_TYPE}\&quot;&gt;ACCESS_TYPE.READ&lt;/a&gt;  permission, unless specified otherwise with the accessType parameter.  &lt;/p&gt; 
#'
#' \itemize{
#' \item \emph{ @param } access.type Enum < [CHANGE_PERMISSIONS, CHANGE_SETTINGS, CREATE, DELETE, DELETE_SUBMISSION, DOWNLOAD, MODERATE, PARTICIPATE, READ, READ_PRIVATE_SUBMISSION, SEND_MESSAGE, SUBMIT, TEAM_MEMBERSHIP_UPDATE, UPDATE, UPDATE_SUBMISSION, UPLOAD] > 
#' \item \emph{ @param } active.only character
#' \item \emph{ @param } evaluation.ids character
#' \item \emph{ @param } limit integer
#' \item \emph{ @param } offset integer
#' \item \emph{ @returnType } \link{PaginatedResultsOfEvaluation} \cr
#'
#'
#' \item status code : 200 | Success
#'
#' \item return type : PaginatedResultsOfEvaluation 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetMySubmissionBundles } \emph{ Gets the requesting users bundled Submissions and SubmissionStatuses to a specified Evaluation.&#39;  }
#' Gets the requesting user&#39;s bundled Submissions and SubmissionStatuses to a specified Evaluation. 
#'
#' \itemize{
#' \item \emph{ @param } eval.id character
#' \item \emph{ @param } limit integer
#' \item \emph{ @param } offset integer
#' \item \emph{ @returnType } \link{PaginatedResultsOfSubmissionBundle} \cr
#'
#'
#' \item status code : 200 | Success
#'
#' \item return type : PaginatedResultsOfSubmissionBundle 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetMySubmissions } \emph{ Gets the requesting user&#39;s Submissions to a specified Evaluation. }
#' Gets the requesting user&#39;s Submissions to a specified Evaluation. 
#'
#' \itemize{
#' \item \emph{ @param } eval.id character
#' \item \emph{ @param } limit integer
#' \item \emph{ @param } offset integer
#' \item \emph{ @returnType } \link{PaginatedResultsOfSubmission} \cr
#'
#'
#' \item status code : 200 | Success
#'
#' \item return type : PaginatedResultsOfSubmission 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetSubmission } \emph{ Gets a Submission. }
#' Gets a Submission.  &lt;p&gt;  &lt;b&gt;Note:&lt;/b&gt; The caller must be granted the &lt;a href&#x3D;\&quot;${org.sagebionetworks.repo.model.ACCESS_TYPE}\&quot;&gt;ACCESS_TYPE.READ_PRIVATE_SUBMISSION&lt;/a&gt; on the specified Evaluation.  &lt;/p&gt; 
#'
#' \itemize{
#' \item \emph{ @param } sub.id character
#' \item \emph{ @returnType } \link{SubmissionModel} \cr
#'
#'
#' \item status code : 200 | Success
#'
#' \item return type : SubmissionModel 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetSubmissionCount } \emph{ Gets the number of Submissions to a specified Evaluation. }
#' Gets the number of Submissions to a specified Evaluation. &lt;b&gt;Note:&lt;/b&gt; The caller must be granted the &lt;a href&#x3D;\&quot;${org.sagebionetworks.repo.model.ACCESS_TYPE}\&quot;&gt;ACCESS_TYPE.READ_PRIVATE_SUBMISSION&lt;/a&gt; on the specified Evaluation. &lt;/p&gt; 
#'
#' \itemize{
#' \item \emph{ @param } eval.id character
#'
#'
#' \item status code : 200 | Success
#'
#' \item return type : integer 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetSubmissionStatus } \emph{ Gets the SubmissionStatus object associated with a specified Submission. }
#' Gets the SubmissionStatus object associated with a specified Submission. &lt;p&gt; &lt;b&gt;Note:&lt;/b&gt; The caller must be granted the &lt;a href&#x3D;\&quot;${org.sagebionetworks.repo.model.ACCESS_TYPE}\&quot;&gt;ACCESS_TYPE.READ&lt;/a&gt; on the specified Evaluation. Furthermore, the caller must be granted the &lt;a href&#x3D;\&quot;${org.sagebionetworks.repo.model.ACCESS_TYPE}\&quot;&gt;ACCESS_TYPE.READ_PRIVATE_SUBMISSION&lt;/a&gt; to see all data marked as \&quot;private\&quot; in the SubmissionStatus.   &lt;b&gt;Service Limits&lt;/b&gt;  &lt;table border&#x3D;\&quot;1\&quot;&gt;  &lt;tr&gt;  &lt;th&gt;resource&lt;/th&gt;  &lt;th&gt;limit&lt;/th&gt;  &lt;/tr&gt;  &lt;tr&gt;  &lt;td&gt;The maximum frequency this method can be called&lt;/td&gt;  &lt;td&gt;1 calls per second&lt;/td&gt;  &lt;/tr&gt;  &lt;/table&gt;  &lt;/p&gt; 
#'
#' \itemize{
#' \item \emph{ @param } sub.id character
#' \item \emph{ @returnType } \link{SubmissionStatusModel} \cr
#'
#'
#' \item status code : 200 | Success
#'
#' \item return type : SubmissionStatusModel 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetTeamSubmissionEligibility } \emph{ Find out whether a Team and its members are eligible to submit to a given Evaluation queue (at the current time).&#39;  }
#' Find out whether a Team and its members are eligible to submit to a given Evaluation queue (at the current time).  The request must include an Evaluation ID and a Team ID.   The &#39;eligibilityStateHash&#39; field of the returned object is a required parameter of the subsequent Team Submission request made for the given Evaluation and Team. (See: &lt;a href&#x3D;\&quot;${POST.evaluation.submission}\&quot;&gt;POST/evaluation/submission&lt;/a&gt;)&#39; 
#'
#' \itemize{
#' \item \emph{ @param } eval.id character
#' \item \emph{ @param } id character
#' \item \emph{ @returnType } \link{TeamSubmissionEligibility} \cr
#'
#'
#' \item status code : 200 | Success
#'
#' \item return type : TeamSubmissionEligibility 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ HasAccess2 } \emph{ Determines whether a specified Synapse user has a certain access type on evaluation. }
#' Determines whether the logged in user has a certain &lt;a href&#x3D;\&quot;${org.sagebionetworks.repo.model.ACCESS_TYPE}\&quot;&gt;ACCESS_TYPE&lt;/a&gt; on the specified Evaluation. 
#'
#' \itemize{
#' \item \emph{ @param } eval.id character
#' \item \emph{ @param } access.type character
#' \item \emph{ @returnType } \link{BooleanResult} \cr
#'
#'
#' \item status code : 200 | Success
#'
#' \item return type : BooleanResult 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ RedirectUrlForFileHandle } \emph{ Gets a pre-signed URL to access a requested File contained within a specified Submission.  }
#' Gets a pre-signed URL to access a requested File contained within a specified Submission. &lt;b&gt;Note:&lt;/b&gt; The caller must be granted the &lt;a href&#x3D;\&quot;${org.sagebionetworks.repo.model.ACCESS_TYPE}\&quot;&gt;ACCESS_TYPE.READ_PRIVATE_SUBMISSION&lt;/a&gt; on the specified Evaluation. &lt;/p&gt; 
#'
#' \itemize{
#' \item \emph{ @param } file.handle.id character
#' \item \emph{ @param } sub.id character
#' \item \emph{ @param } redirect character
#'
#'
#' \item status code : 200 | Success
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ RequestToCancelSubmission } \emph{ User requests to cancel their submission. }
#' User requests to cancel their submission. Only the user who submitted a submission can make this request. 
#'
#' \itemize{
#' \item \emph{ @param } sub.id character
#'
#'
#' \item status code : 204 | The request has been made.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ UpdateAcl } \emph{ Updates the supplied access control list (ACL) for an evaluation. }
#' Updates the supplied access control list (ACL) for an evaluation. The &lt;a href&#x3D;\&quot;${org.sagebionetworks.repo.model.AccessControlList}\&quot;&gt;ACL&lt;/a&gt; to be updated should have the ID of the evaluation. The user should have the proper &lt;a href&#x3D;\&quot;${org.sagebionetworks.evaluation.model.UserEvaluationPermissions}\&quot;&gt;permissions&lt;/a&gt; in order to update the ACL. 
#'
#' \itemize{
#' \item \emph{ @param } access.control.list \link{AccessControlList}
#' \item \emph{ @returnType } \link{AccessControlList} \cr
#'
#'
#' \item status code : 200 | Success
#'
#' \item return type : AccessControlList 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ UpdateEvaluation } \emph{ Updates an Evaluation. }
#' &#39;Updates an Evaluation.   &lt;p&gt;  Synapse employs an Optimistic Concurrency Control (OCC) scheme to handle  concurrent updates. Each time an Evaluation is updated a new etag will be  issued to the Evaluation. When an update is requested, Synapse will compare the  etag of the passed Evaluation with the current etag of the Evaluation. If the  etags do not match, then the update will be rejected with a  PRECONDITION_FAILED (412) response. When this occurs, the caller should  fetch the latest copy of the Evaluation and re-apply any changes, then re-attempt  the Evaluation update.  &lt;/p&gt;   &lt;p&gt;  &lt;b&gt;Note:&lt;/b&gt; The caller must be granted the &lt;a  href&#x3D;\&quot;${org.sagebionetworks.repo.model.ACCESS_TYPE}\&quot;  &gt;ACCESS_TYPE.UPDATE&lt;/a&gt; on the specified Evaluation.  &lt;/p&gt; 
#'
#' \itemize{
#' \item \emph{ @param } eval.id character
#' \item \emph{ @param } evaluation \link{Evaluation}
#' \item \emph{ @returnType } \link{Evaluation} \cr
#'
#'
#' \item status code : 200 | Success
#'
#' \item return type : Evaluation 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ UpdateEvaluationRound } \emph{ Update Evaluation Round }
#' Update Evaluation Round
#'
#' \itemize{
#' \item \emph{ @param } eval.id character
#' \item \emph{ @param } round.id character
#' \item \emph{ @param } evaluation.round \link{EvaluationRound}
#' \item \emph{ @returnType } \link{EvaluationRound} \cr
#'
#'
#' \item status code : 200 | Success
#'
#' \item return type : EvaluationRound 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ UpdateSubmissionStatus } \emph{ Updates a SubmissionStatus object. }
#' Updates a SubmissionStatus object.   &lt;p&gt;  Synapse employs an Optimistic Concurrency Control (OCC) scheme to handle concurrent updates. Each time an SubmissionStatus is updated a new etag will be issued to the SubmissionStatus. When an update is requested, Synapse will compare the etag of the passed SubmissionStatus with the current etag of the SubmissionStatus. If the etags do not match, then the update will be rejected with a PRECONDITION_FAILED (412) response. When this occurs, the caller should fetch the latest copy of the SubmissionStatus and re-apply any changes, then re-attempt the SubmissionStatus update.  &lt;/p&gt;  &lt;p&gt;  &lt;b&gt;Note:&lt;/b&gt; The caller must be granted the &lt;a href&#x3D;\&quot;${org.sagebionetworks.repo.model.ACCESS_TYPE}\&quot;&gt;ACCESS_TYPE.UPDATE_SUBMISSION&lt;/a&gt; on the specified Evaluation.  &lt;/p&gt;  &lt;/p&gt;  &lt;p&gt;  &lt;b&gt;Service Limits&lt;/b&gt;  &lt;table border&#x3D;\&quot;1\&quot;&gt;  &lt;tr&gt;  &lt;th&gt;resource&lt;/th&gt;  &lt;th&gt;limit&lt;/th&gt;  &lt;/tr&gt;  &lt;tr&gt;  &lt;td&gt;The maximum frequency this method can be called&lt;/td&gt;  &lt;td&gt;1 calls per second&lt;/td&gt;  &lt;/tr&gt;  &lt;/table&gt;  &lt;/p&gt; 
#'
#' \itemize{
#' \item \emph{ @param } sub.id character
#' \item \emph{ @param } submission.status.model \link{SubmissionStatusModel}
#' \item \emph{ @returnType } \link{SubmissionStatusModel} \cr
#'
#'
#' \item status code : 200 | Success
#'
#' \item return type : SubmissionStatusModel 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ UpdateSubmissionStatusBatch } \emph{ Update multiple SubmissionStatuses. }
#' Update multiple SubmissionStatuses. The maximum batch size is 500.  To allow upload of more than this maximum, the system supports uploading of a &lt;i&gt;series&lt;/i&gt; of batches. Synapse employs optimistic concurrency on the series in the form of a batch token. Each request (except the first) must include the &#39;&#39;batch token&#39;&#39; returned in the response to the previous batch. If another client begins batch upload simultaneously, a PRECONDITION_FAILED (412) response will be generated and upload must restart from the first batch.  After the final batch is uploaded, the data for the Evaluation queue will be mirrored to the tables which support querying.  Therefore uploaded data will not appear in Evaluation queries until after the final batch is successfully uploaded.  It is the client&#39;&#39;s responsibility to note in each batch request (1) whether it is the first batch in the series and (2) whether it is the last batch.  (For a single batch both are set to &#39;&#39;true&#39;&#39;.)  Failure to use the flags correctly risks corrupted data (due to simultaneous, conflicting uploads by multiple clients) or data not appearing in query results.   &lt;p&gt;  &lt;b&gt;Note:&lt;/b&gt; The caller must be granted the &lt;a href&#x3D;\&quot;${org.sagebionetworks.repo.model.ACCESS_TYPE}\&quot;&gt;ACCESS_TYPE.UPDATE_SUBMISSION&lt;/a&gt; on the specified Evaluation.  &lt;/p&gt; 
#'
#' \itemize{
#' \item \emph{ @param } eval.id character
#' \item \emph{ @param } submission.status.batch \link{SubmissionStatusBatch}
#' \item \emph{ @returnType } \link{BatchUploadResponse} \cr
#'
#'
#' \item status code : 200 | Success
#'
#' \item return type : BatchUploadResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' }
#'
#'
#' @examples
#' \dontrun{
#' ####################  CreateEvaluation  ####################
#'
#' library(synclient)
#' var.evaluation <- Evaluation$new() # Evaluation | 
#'
#' #Creates a new Evaluation.
#' api.instance <- EvaluationServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$CreateEvaluation(evaluation=var.evaluation)
#'
#'
#' ####################  CreateEvaluationRound  ####################
#'
#' library(synclient)
#' var.eval.id <- 'eval.id_example' # character | The ID of the specified Evaluation.
#' var.evaluation.round <- EvaluationRound$new() # EvaluationRound | 
#'
#' #Create Evaluation Round
#' api.instance <- EvaluationServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$CreateEvaluationRound(var.eval.id, evaluation.round=var.evaluation.round)
#'
#'
#' ####################  CreateSubmission  ####################
#'
#' library(synclient)
#' var.challenge.endpoint <- 'challenge.endpoint_example' # character | The portal endpoint prefix to the an entity/challenge page. The entity ID of the challenge project is appended to create the complete URL. In normal operation, this parameter should be omitted.' 
#' var.etag <- 'etag_example' # character | The current eTag of the Entity being submitted
#' var.notification.unsubscribe.endpoint <- 'notification.unsubscribe.endpoint_example' # character | The portal endpoint prefix for one-click email unsubscription. A signed, serialized token is appended to create the complete URL: <a href=\"${org.sagebionetworks.repo.model.message.NotificationSettingsSignedToken}\">NotificationSettingsSignedToken</a>. In normal operation, this parameter should be omitted.' 
#' var.submission.eligibility.hash <- 'submission.eligibility.hash_example' # character | The hash provided by the <a href=\"${org.sagebionetworks.evaluation.model.TeamSubmissionEligibility}\">TeamSubmissionEligibility</a> object. 
#' var.submission.model <- SubmissionModel$new() # SubmissionModel | 
#'
#' #Creates a Submission and sends a submission notification email to the submitter's team members. 
#' api.instance <- EvaluationServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$CreateSubmission(challenge.endpoint=var.challenge.endpoint, etag=var.etag, notification.unsubscribe.endpoint=var.notification.unsubscribe.endpoint, submission.eligibility.hash=var.submission.eligibility.hash, submission.model=var.submission.model)
#'
#'
#' ####################  DeleteAcl  ####################
#'
#' library(synclient)
#' var.eval.id <- 'eval.id_example' # character | The ID of the specified Evaluation.
#'
#' #This method is deprecated and should be removed from future versions of the API.
#' api.instance <- EvaluationServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$DeleteAcl(var.eval.id)
#'
#'
#' ####################  DeleteEvaluation  ####################
#'
#' library(synclient)
#' var.eval.id <- 'eval.id_example' # character | The ID of the specified Evaluation.
#'
#' #Deletes an Evaluation.
#' api.instance <- EvaluationServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$DeleteEvaluation(var.eval.id)
#'
#'
#' ####################  DeleteEvaluationRound  ####################
#'
#' library(synclient)
#' var.eval.id <- 'eval.id_example' # character | The ID of the specified Evaluation.
#' var.round.id <- 'round.id_example' # character | The ID of the evaluation round
#'
#' #Delete Evaluation Round
#' api.instance <- EvaluationServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$DeleteEvaluationRound(var.eval.id, var.round.id)
#'
#'
#' ####################  DeleteSubmission  ####################
#'
#' library(synclient)
#' var.sub.id <- 'sub.id_example' # character | The ID of the Submission
#'
#' #Deletes a Submission and its accompanying SubmissionStatus.
#' api.instance <- EvaluationServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$DeleteSubmission(var.sub.id)
#'
#'
#' ####################  FindEvaluation  ####################
#'
#' library(synclient)
#' var.name <- 'name_example' # character | The name of the desired Evaluation.
#'
#' #Finds an Evaluation by name.
#' api.instance <- EvaluationServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$FindEvaluation(var.name)
#'
#'
#' ####################  GetAcl  ####################
#'
#' library(synclient)
#' var.eval.id <- 'eval.id_example' # character | The ID of the specified Evaluation.
#'
#' #Gets the access control list (ACL) governing the given evaluation.
#' api.instance <- EvaluationServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetAcl(var.eval.id)
#'
#'
#' ####################  GetAllEvaluationRounds  ####################
#'
#' library(synclient)
#' var.eval.id <- 'eval.id_example' # character | The ID of the specified Evaluation.
#' var.evaluation.round.list.request <- EvaluationRoundListRequest$new() # EvaluationRoundListRequest | 
#'
#' #Get all rounds of an Evaluation
#' api.instance <- EvaluationServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetAllEvaluationRounds(var.eval.id, evaluation.round.list.request=var.evaluation.round.list.request)
#'
#'
#' ####################  GetAllSubmissionBundles  ####################
#'
#' library(synclient)
#' var.eval.id <- 'eval.id_example' # character | The ID of the specified Evaluation.
#' var.limit <- 10 # integer | Limits the number of entities that will be fetched for this page. When null it will default to 10.' 
#' var.offset <- 0 # integer | The offset index determines where this page will start from. An index of 0 is the first entity. When null it will default to 0. 
#' var.status <- 'status_example' # character | Submission Status
#'
#' #Gets a collection of bundled Submissions and SubmissionStatuses to a given Evaluation.
#' api.instance <- EvaluationServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetAllSubmissionBundles(var.eval.id, limit=var.limit, offset=var.offset, status=var.status)
#'
#'
#' ####################  GetAllSubmissionStatuses  ####################
#'
#' library(synclient)
#' var.eval.id <- 'eval.id_example' # character | The ID of the specified Evaluation.
#' var.limit <- 10 # integer | Limits the number of entities that will be fetched for this page. When null it will default to 10.' 
#' var.offset <- 0 # integer | The offset index determines where this page will start from. An index of 0 is the first entity. When null it will default to 0. 
#' var.status <- 'status_example' # character | Submission status
#'
#' #Gets a collection of SubmissionStatuses to a specified Evaluation.
#' api.instance <- EvaluationServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetAllSubmissionStatuses(var.eval.id, limit=var.limit, offset=var.offset, status=var.status)
#'
#'
#' ####################  GetAllSubmissions  ####################
#'
#' library(synclient)
#' var.eval.id <- 'eval.id_example' # character | The ID of the specified Evaluation.
#' var.limit <- 10 # integer | Limits the number of entities that will be fetched for this page. When null it will default to 10, max value 100. 
#' var.offset <- 0 # integer | The offset index determines where this page will start from. An index of 0 is the first entity. When null it will default to 0. 
#' var.status <- 'status_example' # character | Status of submission.
#'
#' #Gets a collection of Submissions to a specified Evaluation.
#' api.instance <- EvaluationServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetAllSubmissions(var.eval.id, limit=var.limit, offset=var.offset, status=var.status)
#'
#'
#' ####################  GetAvailableEvaluationsPaginated  ####################
#'
#' library(synclient)
#' var.active.only <- FALSE # character | Retrieve active only evaluation queues
#' var.evaluation.ids <- 'evaluation.ids_example' # character | an optional, comma-delimited list of evaluation IDs to which the response is limited 
#' var.limit <- 10 # integer | Limits the number of entities that will be fetched for this page. When null it will default to 10.' 
#' var.offset <- 0 # integer | The offset index determines where this page will start from. An index of 0 is the first entity. When null it will default to 0. 
#'
#' #Gets a collection of Evaluations in which the user has SUBMIT permission, within a given range. 
#' api.instance <- EvaluationServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetAvailableEvaluationsPaginated(active.only=var.active.only, evaluation.ids=var.evaluation.ids, limit=var.limit, offset=var.offset)
#'
#'
#' ####################  GetEvaluation  ####################
#'
#' library(synclient)
#' var.eval.id <- 'eval.id_example' # character | The ID of the specified Evaluation.
#'
#' #Gets an Evaluation.
#' api.instance <- EvaluationServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetEvaluation(var.eval.id)
#'
#'
#' ####################  GetEvaluationRound  ####################
#'
#' library(synclient)
#' var.eval.id <- 'eval.id_example' # character | The ID of the specified Evaluation.
#' var.round.id <- 'round.id_example' # character | The ID of the evaluation round
#'
#' #Get Evaluation Round
#' api.instance <- EvaluationServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetEvaluationRound(var.eval.id, var.round.id)
#'
#'
#' ####################  GetEvaluationsByContentSourcePaginated  ####################
#'
#' library(synclient)
#' var.id <- 'id_example' # character | the ID of the project
#' var.access.type <- ACCESSTYPE$new() # ACCESSTYPE | The type of access for the user to filter for, optional and defaults to <a href=\"${org.sagebionetworks.repo.model.ACCESS_TYPE}\">ACCESS_TYPE.READ</a> 
#' var.active.only <- FALSE # character | If 'true' then return only those evaluations with rounds defined and for which the current time is in one of the rounds. 
#' var.evaluation.ids <- 'evaluation.ids_example' # character | an optional, comma-delimited list of evaluation IDs to which the response is limited 
#' var.limit <- 10 # integer | Limits the number of entities that will be fetched for this page. When null it will default to 10. 
#' var.offset <- 0 # integer | The offset index determines where this page will start from. An index of 0 is the first entity. When null it will default to 0. 
#'
#' #Gets Evaluations tied to a project.
#' api.instance <- EvaluationServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetEvaluationsByContentSourcePaginated(var.id, access.type=var.access.type, active.only=var.active.only, evaluation.ids=var.evaluation.ids, limit=var.limit, offset=var.offset)
#'
#'
#' ####################  GetEvaluationsPaginated  ####################
#'
#' library(synclient)
#' var.access.type <- 'READ' # character | The type of access for the user to filter for, optional and defaults to <a href=\"${org.sagebionetworks.repo.model.ACCESS_TYPE}\">ACCESS_TYPE.READ</a> 
#' var.active.only <- FALSE # character | If 'true' then return only those evaluations with rounds defined and for which the current time is in one of the rounds. 
#' var.evaluation.ids <- 'evaluation.ids_example' # character | an optional, comma-delimited list of evaluation IDs to which the response is limited 
#' var.limit <- 10 # integer | Maximum number of results returned
#' var.offset <- 0 # integer | The index of the pagination offset. For a page size of 10, the first page would be at offset = 0, and the second page would be at offset = 10. 
#'
#' #Gets a collection of Evaluations, within a given range.
#' api.instance <- EvaluationServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetEvaluationsPaginated(access.type=var.access.type, active.only=var.active.only, evaluation.ids=var.evaluation.ids, limit=var.limit, offset=var.offset)
#'
#'
#' ####################  GetMySubmissionBundles  ####################
#'
#' library(synclient)
#' var.eval.id <- 'eval.id_example' # character | The ID of the specified Evaluation.
#' var.limit <- 10 # integer | Limits the number of entities that will be fetched for this page. When null it will default to 10.' 
#' var.offset <- 0 # integer | The offset index determines where this page will start from. An index of 0 is the first entity. When null it will default to 0. 
#'
#' #Gets the requesting users bundled Submissions and SubmissionStatuses to a specified Evaluation.' 
#' api.instance <- EvaluationServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetMySubmissionBundles(var.eval.id, limit=var.limit, offset=var.offset)
#'
#'
#' ####################  GetMySubmissions  ####################
#'
#' library(synclient)
#' var.eval.id <- 'eval.id_example' # character | The ID of the specified Evaluation.
#' var.limit <- 10 # integer | Limits the number of entities that will be fetched for this page. When null it will default to 10.
#' var.offset <- 0 # integer | The offset index determines where this page will start from. An index of 0 is the first entity. When null it will default to 0.' 
#'
#' #Gets the requesting user's Submissions to a specified Evaluation.
#' api.instance <- EvaluationServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetMySubmissions(var.eval.id, limit=var.limit, offset=var.offset)
#'
#'
#' ####################  GetSubmission  ####################
#'
#' library(synclient)
#' var.sub.id <- 'sub.id_example' # character | The ID of the Submission
#'
#' #Gets a Submission.
#' api.instance <- EvaluationServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetSubmission(var.sub.id)
#'
#'
#' ####################  GetSubmissionCount  ####################
#'
#' library(synclient)
#' var.eval.id <- 'eval.id_example' # character | The ID of the specified Evaluation.
#'
#' #Gets the number of Submissions to a specified Evaluation.
#' api.instance <- EvaluationServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetSubmissionCount(var.eval.id)
#'
#'
#' ####################  GetSubmissionStatus  ####################
#'
#' library(synclient)
#' var.sub.id <- 'sub.id_example' # character | The ID of the Submission
#'
#' #Gets the SubmissionStatus object associated with a specified Submission.
#' api.instance <- EvaluationServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetSubmissionStatus(var.sub.id)
#'
#'
#' ####################  GetTeamSubmissionEligibility  ####################
#'
#' library(synclient)
#' var.eval.id <- 'eval.id_example' # character | The ID of the specified Evaluation.
#' var.id <- 'id_example' # character | The ID of a Team.
#'
#' #Find out whether a Team and its members are eligible to submit to a given Evaluation queue (at the current time).' 
#' api.instance <- EvaluationServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetTeamSubmissionEligibility(var.eval.id, var.id)
#'
#'
#' ####################  HasAccess2  ####################
#'
#' library(synclient)
#' var.eval.id <- 'eval.id_example' # character | The ID of the specified Evaluation.
#' var.access.type <- 'access.type_example' # character | Synapse access type
#'
#' #Determines whether a specified Synapse user has a certain access type on evaluation.
#' api.instance <- EvaluationServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$HasAccess2(var.eval.id, var.access.type)
#'
#'
#' ####################  RedirectUrlForFileHandle  ####################
#'
#' library(synclient)
#' var.file.handle.id <- 'file.handle.id_example' # character | the ID of the requested FileHandle contained in the Submission.
#' var.sub.id <- 'sub.id_example' # character | The ID of the Submission
#' var.redirect <- 'redirect_example' # character | To redirect
#'
#' #Gets a pre-signed URL to access a requested File contained within a specified Submission. 
#' api.instance <- EvaluationServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$RedirectUrlForFileHandle(var.file.handle.id, var.sub.id, redirect=var.redirect)
#'
#'
#' ####################  RequestToCancelSubmission  ####################
#'
#' library(synclient)
#' var.sub.id <- 'sub.id_example' # character | The ID of the Submission
#'
#' #User requests to cancel their submission.
#' api.instance <- EvaluationServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$RequestToCancelSubmission(var.sub.id)
#'
#'
#' ####################  UpdateAcl  ####################
#'
#' library(synclient)
#' var.access.control.list <- AccessControlList$new() # AccessControlList | The ACL being updated.
#'
#' #Updates the supplied access control list (ACL) for an evaluation.
#' api.instance <- EvaluationServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$UpdateAcl(access.control.list=var.access.control.list)
#'
#'
#' ####################  UpdateEvaluation  ####################
#'
#' library(synclient)
#' var.eval.id <- 'eval.id_example' # character | The ID of the specified Evaluation.
#' var.evaluation <- Evaluation$new() # Evaluation | 
#'
#' #Updates an Evaluation.
#' api.instance <- EvaluationServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$UpdateEvaluation(var.eval.id, evaluation=var.evaluation)
#'
#'
#' ####################  UpdateEvaluationRound  ####################
#'
#' library(synclient)
#' var.eval.id <- 'eval.id_example' # character | The ID of the specified Evaluation.
#' var.round.id <- 'round.id_example' # character | The ID of the evaluation round
#' var.evaluation.round <- EvaluationRound$new() # EvaluationRound | 
#'
#' #Update Evaluation Round
#' api.instance <- EvaluationServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$UpdateEvaluationRound(var.eval.id, var.round.id, evaluation.round=var.evaluation.round)
#'
#'
#' ####################  UpdateSubmissionStatus  ####################
#'
#' library(synclient)
#' var.sub.id <- 'sub.id_example' # character | The ID of the Submission
#' var.submission.status.model <- SubmissionStatusModel$new() # SubmissionStatusModel | 
#'
#' #Updates a SubmissionStatus object.
#' api.instance <- EvaluationServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$UpdateSubmissionStatus(var.sub.id, submission.status.model=var.submission.status.model)
#'
#'
#' ####################  UpdateSubmissionStatusBatch  ####################
#'
#' library(synclient)
#' var.eval.id <- 'eval.id_example' # character | The ID of the specified Evaluation.
#' var.submission.status.batch <- SubmissionStatusBatch$new() # SubmissionStatusBatch | 
#'
#' #Update multiple SubmissionStatuses.
#' api.instance <- EvaluationServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$UpdateSubmissionStatusBatch(var.eval.id, submission.status.batch=var.submission.status.batch)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom caTools base64encode
#' @export
EvaluationServicesApi <- R6::R6Class(
  'EvaluationServicesApi',
  public = list(
    apiClient = NULL,
    initialize = function(apiClient){
      if (!missing(apiClient)) {
        self$apiClient <- apiClient
      }
      else {
        self$apiClient <- ApiClient$new()
      }
    },
    CreateEvaluation = function(evaluation=NULL, ...){
      apiResponse <- self$CreateEvaluationWithHttpInfo(evaluation, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CreateEvaluationWithHttpInfo = function(evaluation=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`evaluation`)) {
        body <- `evaluation`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/evaluation"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "Evaluation", loadNamespace("synclient")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CreateEvaluationRound = function(eval.id, evaluation.round=NULL, ...){
      apiResponse <- self$CreateEvaluationRoundWithHttpInfo(eval.id, evaluation.round, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CreateEvaluationRoundWithHttpInfo = function(eval.id, evaluation.round=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`eval.id`)) {
        stop("Missing required parameter `eval.id`.")
      }

      if (!missing(`evaluation.round`)) {
        body <- `evaluation.round`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/evaluation/{evalId}/round"
      if (!missing(`eval.id`)) {
        urlPath <- gsub(paste0("\\{", "evalId", "\\}"), URLencode(as.character(`eval.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "EvaluationRound", loadNamespace("synclient")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CreateSubmission = function(challenge.endpoint=NULL, etag=NULL, notification.unsubscribe.endpoint=NULL, submission.eligibility.hash=NULL, submission.model=NULL, ...){
      apiResponse <- self$CreateSubmissionWithHttpInfo(challenge.endpoint, etag, notification.unsubscribe.endpoint, submission.eligibility.hash, submission.model, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CreateSubmissionWithHttpInfo = function(challenge.endpoint=NULL, etag=NULL, notification.unsubscribe.endpoint=NULL, submission.eligibility.hash=NULL, submission.model=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams['challengeEndpoint'] <- challenge.endpoint

      queryParams['etag'] <- etag

      queryParams['notificationUnsubscribeEndpoint'] <- notification.unsubscribe.endpoint

      queryParams['submissionEligibilityHash'] <- submission.eligibility.hash

      if (!missing(`submission.model`)) {
        body <- `submission.model`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/evaluation/submission"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "SubmissionModel", loadNamespace("synclient")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    DeleteAcl = function(eval.id, ...){
      apiResponse <- self$DeleteAclWithHttpInfo(eval.id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    DeleteAclWithHttpInfo = function(eval.id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`eval.id`)) {
        stop("Missing required parameter `eval.id`.")
      }

      urlPath <- "/evaluation/{evalId}/acl"
      if (!missing(`eval.id`)) {
        urlPath <- gsub(paste0("\\{", "evalId", "\\}"), URLencode(as.character(`eval.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "DELETE",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    DeleteEvaluation = function(eval.id, ...){
      apiResponse <- self$DeleteEvaluationWithHttpInfo(eval.id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    DeleteEvaluationWithHttpInfo = function(eval.id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`eval.id`)) {
        stop("Missing required parameter `eval.id`.")
      }

      urlPath <- "/evaluation/{evalId}"
      if (!missing(`eval.id`)) {
        urlPath <- gsub(paste0("\\{", "evalId", "\\}"), URLencode(as.character(`eval.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "DELETE",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    DeleteEvaluationRound = function(eval.id, round.id, ...){
      apiResponse <- self$DeleteEvaluationRoundWithHttpInfo(eval.id, round.id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    DeleteEvaluationRoundWithHttpInfo = function(eval.id, round.id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`eval.id`)) {
        stop("Missing required parameter `eval.id`.")
      }

      if (missing(`round.id`)) {
        stop("Missing required parameter `round.id`.")
      }

      urlPath <- "/evaluation/{evalId}/round/{roundId}"
      if (!missing(`eval.id`)) {
        urlPath <- gsub(paste0("\\{", "evalId", "\\}"), URLencode(as.character(`eval.id`), reserved = TRUE), urlPath)
      }

      if (!missing(`round.id`)) {
        urlPath <- gsub(paste0("\\{", "roundId", "\\}"), URLencode(as.character(`round.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "DELETE",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    DeleteSubmission = function(sub.id, ...){
      apiResponse <- self$DeleteSubmissionWithHttpInfo(sub.id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    DeleteSubmissionWithHttpInfo = function(sub.id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`sub.id`)) {
        stop("Missing required parameter `sub.id`.")
      }

      urlPath <- "/evaluation/submission/{subId}"
      if (!missing(`sub.id`)) {
        urlPath <- gsub(paste0("\\{", "subId", "\\}"), URLencode(as.character(`sub.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "DELETE",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    FindEvaluation = function(name, ...){
      apiResponse <- self$FindEvaluationWithHttpInfo(name, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    FindEvaluationWithHttpInfo = function(name, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`name`)) {
        stop("Missing required parameter `name`.")
      }

      urlPath <- "/evaluation/name/{name}"
      if (!missing(`name`)) {
        urlPath <- gsub(paste0("\\{", "name", "\\}"), URLencode(as.character(`name`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "Evaluation", loadNamespace("synclient")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetAcl = function(eval.id, ...){
      apiResponse <- self$GetAclWithHttpInfo(eval.id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetAclWithHttpInfo = function(eval.id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`eval.id`)) {
        stop("Missing required parameter `eval.id`.")
      }

      urlPath <- "/evaluation/{evalId}/acl"
      if (!missing(`eval.id`)) {
        urlPath <- gsub(paste0("\\{", "evalId", "\\}"), URLencode(as.character(`eval.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "AccessControlList", loadNamespace("synclient")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetAllEvaluationRounds = function(eval.id, evaluation.round.list.request=NULL, ...){
      apiResponse <- self$GetAllEvaluationRoundsWithHttpInfo(eval.id, evaluation.round.list.request, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetAllEvaluationRoundsWithHttpInfo = function(eval.id, evaluation.round.list.request=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`eval.id`)) {
        stop("Missing required parameter `eval.id`.")
      }

      if (!missing(`evaluation.round.list.request`)) {
        body <- `evaluation.round.list.request`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/evaluation/{evalId}/round/list"
      if (!missing(`eval.id`)) {
        urlPath <- gsub(paste0("\\{", "evalId", "\\}"), URLencode(as.character(`eval.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "EvaluationRoundListResponse", loadNamespace("synclient")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetAllSubmissionBundles = function(eval.id, limit=10, offset=0, status=NULL, ...){
      apiResponse <- self$GetAllSubmissionBundlesWithHttpInfo(eval.id, limit, offset, status, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetAllSubmissionBundlesWithHttpInfo = function(eval.id, limit=10, offset=0, status=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`eval.id`)) {
        stop("Missing required parameter `eval.id`.")
      }

      queryParams['limit'] <- limit

      queryParams['offset'] <- offset

      queryParams['status'] <- status

      urlPath <- "/evaluation/{evalId}/submission/bundle/all"
      if (!missing(`eval.id`)) {
        urlPath <- gsub(paste0("\\{", "evalId", "\\}"), URLencode(as.character(`eval.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "PaginatedResultsOfSubmissionBundle", loadNamespace("synclient")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetAllSubmissionStatuses = function(eval.id, limit=10, offset=0, status=NULL, ...){
      apiResponse <- self$GetAllSubmissionStatusesWithHttpInfo(eval.id, limit, offset, status, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetAllSubmissionStatusesWithHttpInfo = function(eval.id, limit=10, offset=0, status=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`eval.id`)) {
        stop("Missing required parameter `eval.id`.")
      }

      queryParams['limit'] <- limit

      queryParams['offset'] <- offset

      queryParams['status'] <- status

      urlPath <- "/evaluation/{evalId}/submission/status/all"
      if (!missing(`eval.id`)) {
        urlPath <- gsub(paste0("\\{", "evalId", "\\}"), URLencode(as.character(`eval.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "PaginatedResultsOfSubmissionStatus", loadNamespace("synclient")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetAllSubmissions = function(eval.id, limit=10, offset=0, status=NULL, ...){
      apiResponse <- self$GetAllSubmissionsWithHttpInfo(eval.id, limit, offset, status, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetAllSubmissionsWithHttpInfo = function(eval.id, limit=10, offset=0, status=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`eval.id`)) {
        stop("Missing required parameter `eval.id`.")
      }

      queryParams['limit'] <- limit

      queryParams['offset'] <- offset

      queryParams['status'] <- status

      urlPath <- "/evaluation/{evalId}/submission/all"
      if (!missing(`eval.id`)) {
        urlPath <- gsub(paste0("\\{", "evalId", "\\}"), URLencode(as.character(`eval.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "PaginatedResultsOfSubmission", loadNamespace("synclient")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetAvailableEvaluationsPaginated = function(active.only=FALSE, evaluation.ids=NULL, limit=10, offset=0, ...){
      apiResponse <- self$GetAvailableEvaluationsPaginatedWithHttpInfo(active.only, evaluation.ids, limit, offset, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetAvailableEvaluationsPaginatedWithHttpInfo = function(active.only=FALSE, evaluation.ids=NULL, limit=10, offset=0, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams['activeOnly'] <- active.only

      queryParams['evaluationIds'] <- evaluation.ids

      queryParams['limit'] <- limit

      queryParams['offset'] <- offset

      urlPath <- "/evaluation/available"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "PaginatedResultsOfEvaluation", loadNamespace("synclient")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetEvaluation = function(eval.id, ...){
      apiResponse <- self$GetEvaluationWithHttpInfo(eval.id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetEvaluationWithHttpInfo = function(eval.id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`eval.id`)) {
        stop("Missing required parameter `eval.id`.")
      }

      urlPath <- "/evaluation/{evalId}"
      if (!missing(`eval.id`)) {
        urlPath <- gsub(paste0("\\{", "evalId", "\\}"), URLencode(as.character(`eval.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "Evaluation", loadNamespace("synclient")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetEvaluationRound = function(eval.id, round.id, ...){
      apiResponse <- self$GetEvaluationRoundWithHttpInfo(eval.id, round.id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetEvaluationRoundWithHttpInfo = function(eval.id, round.id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`eval.id`)) {
        stop("Missing required parameter `eval.id`.")
      }

      if (missing(`round.id`)) {
        stop("Missing required parameter `round.id`.")
      }

      urlPath <- "/evaluation/{evalId}/round/{roundId}"
      if (!missing(`eval.id`)) {
        urlPath <- gsub(paste0("\\{", "evalId", "\\}"), URLencode(as.character(`eval.id`), reserved = TRUE), urlPath)
      }

      if (!missing(`round.id`)) {
        urlPath <- gsub(paste0("\\{", "roundId", "\\}"), URLencode(as.character(`round.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "EvaluationRound", loadNamespace("synclient")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetEvaluationsByContentSourcePaginated = function(id, access.type=NULL, active.only=FALSE, evaluation.ids=NULL, limit=10, offset=0, ...){
      apiResponse <- self$GetEvaluationsByContentSourcePaginatedWithHttpInfo(id, access.type, active.only, evaluation.ids, limit, offset, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetEvaluationsByContentSourcePaginatedWithHttpInfo = function(id, access.type=NULL, active.only=FALSE, evaluation.ids=NULL, limit=10, offset=0, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      queryParams['accessType'] <- access.type

      queryParams['activeOnly'] <- active.only

      queryParams['evaluationIds'] <- evaluation.ids

      queryParams['limit'] <- limit

      queryParams['offset'] <- offset

      urlPath <- "/entity/{id}/evaluation"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "PaginatedResultsOfEvaluation", loadNamespace("synclient")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetEvaluationsPaginated = function(access.type='READ', active.only=FALSE, evaluation.ids=NULL, limit=10, offset=0, ...){
      apiResponse <- self$GetEvaluationsPaginatedWithHttpInfo(access.type, active.only, evaluation.ids, limit, offset, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetEvaluationsPaginatedWithHttpInfo = function(access.type='READ', active.only=FALSE, evaluation.ids=NULL, limit=10, offset=0, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams['accessType'] <- access.type

      queryParams['activeOnly'] <- active.only

      queryParams['evaluationIds'] <- evaluation.ids

      queryParams['limit'] <- limit

      queryParams['offset'] <- offset

      urlPath <- "/evaluation"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "PaginatedResultsOfEvaluation", loadNamespace("synclient")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetMySubmissionBundles = function(eval.id, limit=10, offset=0, ...){
      apiResponse <- self$GetMySubmissionBundlesWithHttpInfo(eval.id, limit, offset, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetMySubmissionBundlesWithHttpInfo = function(eval.id, limit=10, offset=0, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`eval.id`)) {
        stop("Missing required parameter `eval.id`.")
      }

      queryParams['limit'] <- limit

      queryParams['offset'] <- offset

      urlPath <- "/evaluation/{evalId}/submission/bundle"
      if (!missing(`eval.id`)) {
        urlPath <- gsub(paste0("\\{", "evalId", "\\}"), URLencode(as.character(`eval.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "PaginatedResultsOfSubmissionBundle", loadNamespace("synclient")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetMySubmissions = function(eval.id, limit=10, offset=0, ...){
      apiResponse <- self$GetMySubmissionsWithHttpInfo(eval.id, limit, offset, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetMySubmissionsWithHttpInfo = function(eval.id, limit=10, offset=0, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`eval.id`)) {
        stop("Missing required parameter `eval.id`.")
      }

      queryParams['limit'] <- limit

      queryParams['offset'] <- offset

      urlPath <- "/evaluation/{evalId}/submission"
      if (!missing(`eval.id`)) {
        urlPath <- gsub(paste0("\\{", "evalId", "\\}"), URLencode(as.character(`eval.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "PaginatedResultsOfSubmission", loadNamespace("synclient")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetSubmission = function(sub.id, ...){
      apiResponse <- self$GetSubmissionWithHttpInfo(sub.id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetSubmissionWithHttpInfo = function(sub.id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`sub.id`)) {
        stop("Missing required parameter `sub.id`.")
      }

      urlPath <- "/evaluation/submission/{subId}"
      if (!missing(`sub.id`)) {
        urlPath <- gsub(paste0("\\{", "subId", "\\}"), URLencode(as.character(`sub.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "SubmissionModel", loadNamespace("synclient")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetSubmissionCount = function(eval.id, ...){
      apiResponse <- self$GetSubmissionCountWithHttpInfo(eval.id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetSubmissionCountWithHttpInfo = function(eval.id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`eval.id`)) {
        stop("Missing required parameter `eval.id`.")
      }

      urlPath <- "/evaluation/{evalId}/submission/count"
      if (!missing(`eval.id`)) {
        urlPath <- gsub(paste0("\\{", "evalId", "\\}"), URLencode(as.character(`eval.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "integer", loadNamespace("synclient")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetSubmissionStatus = function(sub.id, ...){
      apiResponse <- self$GetSubmissionStatusWithHttpInfo(sub.id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetSubmissionStatusWithHttpInfo = function(sub.id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`sub.id`)) {
        stop("Missing required parameter `sub.id`.")
      }

      urlPath <- "/evaluation/submission/{subId}/status"
      if (!missing(`sub.id`)) {
        urlPath <- gsub(paste0("\\{", "subId", "\\}"), URLencode(as.character(`sub.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "SubmissionStatusModel", loadNamespace("synclient")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetTeamSubmissionEligibility = function(eval.id, id, ...){
      apiResponse <- self$GetTeamSubmissionEligibilityWithHttpInfo(eval.id, id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetTeamSubmissionEligibilityWithHttpInfo = function(eval.id, id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`eval.id`)) {
        stop("Missing required parameter `eval.id`.")
      }

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      urlPath <- "/evaluation/{evalId}/team/{id}/SubmissionEligibility"
      if (!missing(`eval.id`)) {
        urlPath <- gsub(paste0("\\{", "evalId", "\\}"), URLencode(as.character(`eval.id`), reserved = TRUE), urlPath)
      }

      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "TeamSubmissionEligibility", loadNamespace("synclient")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    HasAccess2 = function(eval.id, access.type, ...){
      apiResponse <- self$HasAccess2WithHttpInfo(eval.id, access.type, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    HasAccess2WithHttpInfo = function(eval.id, access.type, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`eval.id`)) {
        stop("Missing required parameter `eval.id`.")
      }

      if (missing(`access.type`)) {
        stop("Missing required parameter `access.type`.")
      }

      queryParams['accessType'] <- access.type

      urlPath <- "/evaluation/{evalId}/access"
      if (!missing(`eval.id`)) {
        urlPath <- gsub(paste0("\\{", "evalId", "\\}"), URLencode(as.character(`eval.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "BooleanResult", loadNamespace("synclient")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    RedirectUrlForFileHandle = function(file.handle.id, sub.id, redirect=NULL, ...){
      apiResponse <- self$RedirectUrlForFileHandleWithHttpInfo(file.handle.id, sub.id, redirect, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    RedirectUrlForFileHandleWithHttpInfo = function(file.handle.id, sub.id, redirect=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`file.handle.id`)) {
        stop("Missing required parameter `file.handle.id`.")
      }

      if (missing(`sub.id`)) {
        stop("Missing required parameter `sub.id`.")
      }

      queryParams['redirect'] <- redirect

      urlPath <- "/evaluation/submission/{subId}/file/{fileHandleId}"
      if (!missing(`file.handle.id`)) {
        urlPath <- gsub(paste0("\\{", "fileHandleId", "\\}"), URLencode(as.character(`file.handle.id`), reserved = TRUE), urlPath)
      }

      if (!missing(`sub.id`)) {
        urlPath <- gsub(paste0("\\{", "subId", "\\}"), URLencode(as.character(`sub.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "character", loadNamespace("synclient")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    RequestToCancelSubmission = function(sub.id, ...){
      apiResponse <- self$RequestToCancelSubmissionWithHttpInfo(sub.id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    RequestToCancelSubmissionWithHttpInfo = function(sub.id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`sub.id`)) {
        stop("Missing required parameter `sub.id`.")
      }

      urlPath <- "/evaluation/submission/{subId}/cancellation"
      if (!missing(`sub.id`)) {
        urlPath <- gsub(paste0("\\{", "subId", "\\}"), URLencode(as.character(`sub.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PUT",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    UpdateAcl = function(access.control.list=NULL, ...){
      apiResponse <- self$UpdateAclWithHttpInfo(access.control.list, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    UpdateAclWithHttpInfo = function(access.control.list=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`access.control.list`)) {
        body <- `access.control.list`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/evaluation/acl"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PUT",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "AccessControlList", loadNamespace("synclient")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    UpdateEvaluation = function(eval.id, evaluation=NULL, ...){
      apiResponse <- self$UpdateEvaluationWithHttpInfo(eval.id, evaluation, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    UpdateEvaluationWithHttpInfo = function(eval.id, evaluation=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`eval.id`)) {
        stop("Missing required parameter `eval.id`.")
      }

      if (!missing(`evaluation`)) {
        body <- `evaluation`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/evaluation/{evalId}"
      if (!missing(`eval.id`)) {
        urlPath <- gsub(paste0("\\{", "evalId", "\\}"), URLencode(as.character(`eval.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PUT",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "Evaluation", loadNamespace("synclient")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    UpdateEvaluationRound = function(eval.id, round.id, evaluation.round=NULL, ...){
      apiResponse <- self$UpdateEvaluationRoundWithHttpInfo(eval.id, round.id, evaluation.round, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    UpdateEvaluationRoundWithHttpInfo = function(eval.id, round.id, evaluation.round=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`eval.id`)) {
        stop("Missing required parameter `eval.id`.")
      }

      if (missing(`round.id`)) {
        stop("Missing required parameter `round.id`.")
      }

      if (!missing(`evaluation.round`)) {
        body <- `evaluation.round`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/evaluation/{evalId}/round/{roundId}"
      if (!missing(`eval.id`)) {
        urlPath <- gsub(paste0("\\{", "evalId", "\\}"), URLencode(as.character(`eval.id`), reserved = TRUE), urlPath)
      }

      if (!missing(`round.id`)) {
        urlPath <- gsub(paste0("\\{", "roundId", "\\}"), URLencode(as.character(`round.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PUT",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "EvaluationRound", loadNamespace("synclient")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    UpdateSubmissionStatus = function(sub.id, submission.status.model=NULL, ...){
      apiResponse <- self$UpdateSubmissionStatusWithHttpInfo(sub.id, submission.status.model, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    UpdateSubmissionStatusWithHttpInfo = function(sub.id, submission.status.model=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`sub.id`)) {
        stop("Missing required parameter `sub.id`.")
      }

      if (!missing(`submission.status.model`)) {
        body <- `submission.status.model`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/evaluation/submission/{subId}/status"
      if (!missing(`sub.id`)) {
        urlPath <- gsub(paste0("\\{", "subId", "\\}"), URLencode(as.character(`sub.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PUT",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "SubmissionStatusModel", loadNamespace("synclient")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    UpdateSubmissionStatusBatch = function(eval.id, submission.status.batch=NULL, ...){
      apiResponse <- self$UpdateSubmissionStatusBatchWithHttpInfo(eval.id, submission.status.batch, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    UpdateSubmissionStatusBatchWithHttpInfo = function(eval.id, submission.status.batch=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`eval.id`)) {
        stop("Missing required parameter `eval.id`.")
      }

      if (!missing(`submission.status.batch`)) {
        body <- `submission.status.batch`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/evaluation/{evalId}/statusBatch"
      if (!missing(`eval.id`)) {
        urlPath <- gsub(paste0("\\{", "evalId", "\\}"), URLencode(as.character(`eval.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PUT",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "BatchUploadResponse", loadNamespace("synclient")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    }
  )
)
