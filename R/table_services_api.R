# Platform Repository Service
#
# Platform Repository Service - Sage Bionetworks Platform 
#
# The version of the OpenAPI document: develop-SNAPSHOT
# Contact: thomas.yu@sagebionetworks.org
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title TableServices operations
#' @description synclient.TableServices
#' @format An \code{R6Class} generator object
#' @field apiClient Handles the client-server communication.
#'
#' @section Methods:
#' \describe{
#' \strong{ CreateSnapshot } \emph{ Request to create a new snapshot of a table. }
#' Request to create a new snapshot of a table. The provided comment, label, and activity ID will be applied to the current version thereby creating a snapshot and locking the current version. After the snapshot is created a new version will be started with an &#39;in-progress&#39; label.  NOTE: This service is for TableEntity only. Snapshots of EntityView require asynchronous processing and can be created via: POST /entity/{id}/table/transaction/async/start 
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @param } snapshot.request \link{SnapshotRequest}
#' \item \emph{ @returnType } \link{SnapshotResponse} \cr
#'
#'
#' \item status code : 201 | Success
#'
#' \item return type : SnapshotResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CsvDownloadAsyncGet } \emph{ Asynchronously get the results of a csv download started with. }
#' Asynchronously get the results of a csv download started with POST  Note: When the result is not ready yet, this method will return a status code of 202 (ACCEPTED) and the response body will be a AsynchronousJobStatus 
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @param } async.token character
#' \item \emph{ @returnType } \link{DownloadFromTableResult} \cr
#'
#'
#' \item status code : 201 | Success
#'
#' \item return type : DownloadFromTableResult 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CsvDownloadAsyncStart } \emph{ Asynchronously start a csv download. }
#' Asynchronously start a csv download. Use the returned job id and  /entity/{id}/table/download/csv/async/get to get the results of the query 
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @param } download.from.table.request \link{DownloadFromTableRequest}
#' \item \emph{ @returnType } \link{AsyncJobId} \cr
#'
#'
#' \item status code : 201 | Success
#'
#' \item return type : AsyncJobId 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ FilePreviewRedirectUrlForRow } \emph{ Get the preview URL of the file associated with a specific version of a row and file handle column.  }
#' Get the preview URL of the file associated with a specific version of a row and file handle column.  Note: This call will result in a HTTP temporary redirect (307), to the actual file URL if the caller meets all of the download requirements. 
#'
#' \itemize{
#' \item \emph{ @param } column.id character
#' \item \emph{ @param } id character
#' \item \emph{ @param } row.id numeric
#' \item \emph{ @param } version.number numeric
#' \item \emph{ @param } redirect character
#'
#'
#' \item status code : 200 | Success
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ FileRedirectUrlForRow } \emph{ Get the actual URL of the file associated with a specific version of a row and file handle column.  }
#' Get the actual URL of the file associated with a specific version of a row and file handle column.  Note: This call will result in a HTTP temporary redirect (307), to the actual file URL if the caller meets all of the download requirements. 
#'
#' \itemize{
#' \item \emph{ @param } column.id character
#' \item \emph{ @param } id character
#' \item \emph{ @param } row.id numeric
#' \item \emph{ @param } version.number numeric
#' \item \emph{ @param } redirect character
#'
#'
#' \item status code : 200 | Success
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetColumnForTable } \emph{ Given the ID of a. }
#' Given the ID of a &lt;a href&#x3D;\&quot;${org.sagebionetworks.repo.model.table.TableEntity}\&quot;&gt;TableEntity&lt;/a&gt;, get its list of &lt;ahref&#x3D;\&quot;${org.sagebionetworks.repo.model.table.ColumnModel}\&quot;&gt;ColumnModels&lt;/a&gt; that are currently assigned to the table.  &lt;p&gt;  &lt;b&gt;Service Limits&lt;/b&gt;  &lt;table border&#x3D;\&quot;1\&quot;&gt;  &lt;tr&gt;  &lt;th&gt;resource&lt;/th&gt;  &lt;th&gt;limit&lt;/th&gt;  &lt;/tr&gt;  &lt;tr&gt;  &lt;td&gt;The maximum frequency this method can be called&lt;/td&gt;  &lt;td&gt;6 calls per minute&lt;/td&gt;  &lt;/tr&gt;  &lt;/table&gt;  &lt;/p&gt; 
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @returnType } \link{PaginatedColumnModels} \cr
#'
#'
#' \item status code : 200 | Success
#'
#' \item return type : PaginatedColumnModels 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetFileHandles } \emph{ . }
#' This method is used to get file handle information for rows in a TableEntity. The columns in the passed in RowReferenceSet need to be FILEHANDLEID columns and the rows in the passed in RowReferenceSet need to exists (a 400 will be returned if a row ID is provided that does not actually exist). The order of the returned rows of file handles is the same as the order of the rows requested, and the order of the file handles in each row is the same as the order of the columns requested.  Note: The caller must have the READ permission on the TableEntity to make this call.  &lt;b&gt;Service Limits&lt;/b&gt;  &lt;table border&#x3D;\&quot;1\&quot;&gt;  &lt;tr&gt;  &lt;th&gt;resource&lt;/th&gt;  &lt;th&gt;limit&lt;/th&gt;  &lt;/tr&gt;  &lt;tr&gt;  &lt;td&gt;The maximum frequency this method can be called&lt;/td&gt;  &lt;td&gt;1 calls per second&lt;/td&gt;  &lt;/tr&gt;  &lt;/table&gt; 
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @param } row.reference.set \link{RowReferenceSet}
#' \item \emph{ @returnType } \link{TableFileHandleResults} \cr
#'
#'
#' \item status code : 200 | Success
#'
#' \item return type : TableFileHandleResults 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetTableTransactionResult } \emph{ Asynchronously get the results of a table update transaction started with. }
#' Asynchronously get the results of a table update transaction started with POST /entity/{id}/table/transaction/async/start&lt;/a&gt;  Note: When the result is not ready yet, this method will return a status code of 202 (ACCEPTED) and the response body will be a AsynchronousJobStatus object. 
#'
#' \itemize{
#' \item \emph{ @param } async.token character
#' \item \emph{ @param } id character
#' \item \emph{ @returnType } \link{TableUpdateTransactionResponse} \cr
#'
#'
#' \item status code : 201 | Success
#'
#' \item return type : TableUpdateTransactionResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ QueryAsyncGet } \emph{ Asynchronously get the results of a query started with. }
#' Asynchronously get the results of a query started with POST /entity/{id}/table/query/async/start  Note: When the result is not ready yet, this method will return a status code of 202 (ACCEPTED) and the response body will be a AsynchronousJobStatus object. 
#'
#' \itemize{
#' \item \emph{ @param } async.token character
#' \item \emph{ @param } id character
#' \item \emph{ @returnType } \link{QueryResultBundle} \cr
#'
#'
#' \item status code : 201 | Success
#'
#' \item return type : QueryResultBundle 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ QueryAsyncStart } \emph{ Asynchronously start a query. }
#' Asynchronously start a query. Use the returned job id and GET /entity/{id}/table/query/async/get&lt;/a&gt; to get the results of the query  Using a &#39;SQL like&#39; syntax, query the current version of the rows in a single table. The following pseudo-syntax is the basic supported format:   SELECT &lt;br&gt;  [ALL | DISTINCT] select_expr [, select_expr ...] &lt;br&gt;  FROM synapse_table_id &lt;br&gt;  [WHERE where_condition] &lt;br&gt;  [GROUP BY {col_name [, [col_name * ...] } &lt;br&gt;  [ORDER BY {col_name [ [ASC | DESC] [, col_name [ [ASC | DESC] ]}&lt;br&gt;  [LIMIT row_count [ OFFSET offset ] ]&lt;br&gt;   &lt;p&gt;  Note: Sub-queries and joining tables is not supported.  &lt;/p&gt;  &lt;p&gt;  This services depends on an index that is created/update asynchronously from table creation and update events. This means there could be short window of time when the index is inconsistent with the true state of the table. When the index is out-of-synch, then a status code of 202 (ACCEPTED) will be returned and the response body will be a TableStatus object. The TableStatus will indicates the current status of the index including how much work is remaining until the index is consistent with the truth of the table.  The &#39;partsMask&#39; is an integer \&quot;mask\&quot; that can be combined into to request any desired part. As of this writing, the mask is defined as follows QueryBundleRequest  &lt;ul&gt;  &lt;li&gt;Query Results &lt;i&gt;(queryResults)&lt;/i&gt; &#x3D; 0x1&lt;/li&gt;  &lt;li&gt;Query Count &lt;i&gt;(queryCount)&lt;/i&gt; &#x3D; 0x2&lt;/li&gt;  &lt;li&gt;Select Columns &lt;i&gt;(selectColumns)&lt;/i&gt; &#x3D; 0x4&lt;/li&gt;  &lt;li&gt;Max Rows Per Page &lt;i&gt;(maxRowsPerPage)&lt;/i&gt; &#x3D; 0x8&lt;/li&gt;  &lt;li&gt;The Table Columns &lt;i&gt;(columnModels)&lt;/i&gt; &#x3D; 0x10&lt;/li&gt;  &lt;li&gt;Facet statistics for each faceted column &lt;i&gt;(facetStatistics)&lt;/i&gt; &#x3D; 0x20&lt;/li&gt;  &lt;li&gt;The sum of the file sizes &lt;i&gt;(sumFileSizesBytes)&lt;/i&gt; &#x3D; 0x40&lt;/li&gt;  &lt;/ul&gt;  &lt;/p&gt;  &lt;p&gt;  For example, to request all parts, the request mask value should be: &lt;br&gt; 0x1 OR 0x2 OR 0x4 OR 0x8 OR 0x10 OR 0x20 OR 0x40 &#x3D; 0x7F.  &lt;/p&gt;  &lt;p&gt;  Note: The caller must have the READ permission on the TableEntity to make this call.  &lt;/p&gt; 
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @param } query.bundle.request \link{QueryBundleRequest}
#' \item \emph{ @returnType } \link{AsyncJobId} \cr
#'
#'
#' \item status code : 201 | Success
#'
#' \item return type : AsyncJobId 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ StartTableTransactionJob } \emph{ Start a table update job that will attempt to make all of the requested changes in a single transaction.  }
#' Start a table update job that will attempt to make all of the requested changes in a single transaction. All updates will either succeed or fail as a unit.  All update requests must be for the same table.  &lt;p&gt;  Note: The caller must have the UPDATE permission on the TableEntity to make this call.  &lt;/p&gt;  &lt;p&gt;  &lt;b&gt;Service Limits&lt;/b&gt;  &lt;table border&#x3D;\&quot;1\&quot;&gt;  &lt;tr&gt;  &lt;th&gt;resource&lt;/th&gt;  &lt;th&gt;limit&lt;/th&gt;  &lt;/tr&gt;  &lt;tr&gt;  &lt;td&gt;The maximum size of a PartialRow change &lt;/td&gt;  &lt;td&gt;2 MB&lt;/td&gt;  &lt;/tr&gt;  &lt;tr&gt;  &lt;td&gt;The maximum size of a CSV that can be appended to a table&lt;/td&gt;  &lt;td&gt;1 GB&lt;/td&gt;  &lt;/tr&gt;  &lt;/table&gt;  &lt;/p&gt; 
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @param } table.update.transaction.request \link{TableUpdateTransactionRequest}
#' \item \emph{ @returnType } \link{AsyncJobId} \cr
#'
#'
#' \item status code : 201 | Success
#'
#' \item return type : AsyncJobId 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' }
#'
#'
#' @examples
#' \dontrun{
#' ####################  CreateSnapshot  ####################
#'
#' library(synclient)
#' var.id <- 'id_example' # character | The ID of a Table Entity.
#' var.snapshot.request <- SnapshotRequest$new() # SnapshotRequest | 
#'
#' #Request to create a new snapshot of a table.
#' api.instance <- TableServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$CreateSnapshot(var.id, snapshot.request=var.snapshot.request)
#'
#'
#' ####################  CsvDownloadAsyncGet  ####################
#'
#' library(synclient)
#' var.id <- 'id_example' # character | The ID of a TableEntity.
#' var.async.token <- 'async.token_example' # character | Async Token
#'
#' #Asynchronously get the results of a csv download started with.
#' api.instance <- TableServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$CsvDownloadAsyncGet(var.id, var.async.token)
#'
#'
#' ####################  CsvDownloadAsyncStart  ####################
#'
#' library(synclient)
#' var.id <- 'id_example' # character | The ID of a TableEntity.
#' var.download.from.table.request <- DownloadFromTableRequest$new() # DownloadFromTableRequest | 
#'
#' #Asynchronously start a csv download.
#' api.instance <- TableServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$CsvDownloadAsyncStart(var.id, download.from.table.request=var.download.from.table.request)
#'
#'
#' ####################  FilePreviewRedirectUrlForRow  ####################
#'
#' library(synclient)
#' var.column.id <- 'column.id_example' # character | The ID of the Table column
#' var.id <- 'id_example' # character | The ID of the FileEntity to get.
#' var.row.id <- 3.4 # numeric | The ID of the Table Row
#' var.version.number <- 3.4 # numeric | The version of the Table Row
#' var.redirect <- 'redirect_example' # character | When set to false, the URL will be returned as text/plain instead of redirecting. 
#'
#' #Get the preview URL of the file associated with a specific version of a row and file handle column. 
#' api.instance <- TableServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$FilePreviewRedirectUrlForRow(var.column.id, var.id, var.row.id, var.version.number, redirect=var.redirect)
#'
#'
#' ####################  FileRedirectUrlForRow  ####################
#'
#' library(synclient)
#' var.column.id <- 'column.id_example' # character | The ID of the Table column
#' var.id <- 'id_example' # character | The ID of the FileEntity to get.
#' var.row.id <- 3.4 # numeric | The ID of the Table Row
#' var.version.number <- 3.4 # numeric | The version of the Table Row
#' var.redirect <- 'redirect_example' # character | When set to false, the URL will be returned as text/plain instead of redirecting. 
#'
#' #Get the actual URL of the file associated with a specific version of a row and file handle column. 
#' api.instance <- TableServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$FileRedirectUrlForRow(var.column.id, var.id, var.row.id, var.version.number, redirect=var.redirect)
#'
#'
#' ####################  GetColumnForTable  ####################
#'
#' library(synclient)
#' var.id <- 'id_example' # character | The ID of a Table.
#'
#' #Given the ID of a.
#' api.instance <- TableServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetColumnForTable(var.id)
#'
#'
#' ####################  GetFileHandles  ####################
#'
#' library(synclient)
#' var.id <- 'id_example' # character | The ID of a TableEntity.
#' var.row.reference.set <- RowReferenceSet$new() # RowReferenceSet | 
#'
#' #.
#' api.instance <- TableServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetFileHandles(var.id, row.reference.set=var.row.reference.set)
#'
#'
#' ####################  GetTableTransactionResult  ####################
#'
#' library(synclient)
#' var.async.token <- 'async.token_example' # character | The token returned when the job was started.
#' var.id <- 'id_example' # character | The ID of a Table entity.
#'
#' #Asynchronously get the results of a table update transaction started with.
#' api.instance <- TableServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetTableTransactionResult(var.async.token, var.id)
#'
#'
#' ####################  QueryAsyncGet  ####################
#'
#' library(synclient)
#' var.async.token <- 'async.token_example' # character | Async Token
#' var.id <- 'id_example' # character | The ID of the TableEntity.
#'
#' #Asynchronously get the results of a query started with.
#' api.instance <- TableServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$QueryAsyncGet(var.async.token, var.id)
#'
#'
#' ####################  QueryAsyncStart  ####################
#'
#' library(synclient)
#' var.id <- 'id_example' # character | The ID of a TableEntity.
#' var.query.bundle.request <- QueryBundleRequest$new() # QueryBundleRequest | 
#'
#' #Asynchronously start a query.
#' api.instance <- TableServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$QueryAsyncStart(var.id, query.bundle.request=var.query.bundle.request)
#'
#'
#' ####################  StartTableTransactionJob  ####################
#'
#' library(synclient)
#' var.id <- 'id_example' # character | The ID of a Table Entity.
#' var.table.update.transaction.request <- TableUpdateTransactionRequest$new() # TableUpdateTransactionRequest | 
#'
#' #Start a table update job that will attempt to make all of the requested changes in a single transaction. 
#' api.instance <- TableServicesApi$new()
#'
#' #Configure HTTP basic authorization: bearerAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$StartTableTransactionJob(var.id, table.update.transaction.request=var.table.update.transaction.request)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom caTools base64encode
#' @export
TableServicesApi <- R6::R6Class(
  'TableServicesApi',
  public = list(
    apiClient = NULL,
    initialize = function(apiClient){
      if (!missing(apiClient)) {
        self$apiClient <- apiClient
      }
      else {
        self$apiClient <- ApiClient$new()
      }
    },
    CreateSnapshot = function(id, snapshot.request=NULL, ...){
      apiResponse <- self$CreateSnapshotWithHttpInfo(id, snapshot.request, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CreateSnapshotWithHttpInfo = function(id, snapshot.request=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      if (!missing(`snapshot.request`)) {
        body <- `snapshot.request`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/entity/{id}/table/snapshot"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "SnapshotResponse", loadNamespace("synclient")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CsvDownloadAsyncGet = function(id, async.token, ...){
      apiResponse <- self$CsvDownloadAsyncGetWithHttpInfo(id, async.token, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CsvDownloadAsyncGetWithHttpInfo = function(id, async.token, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      if (missing(`async.token`)) {
        stop("Missing required parameter `async.token`.")
      }

      urlPath <- "/entity/{id}/table/download/csv/async/get/{asyncToken}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      if (!missing(`async.token`)) {
        urlPath <- gsub(paste0("\\{", "asyncToken", "\\}"), URLencode(as.character(`async.token`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "DownloadFromTableResult", loadNamespace("synclient")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CsvDownloadAsyncStart = function(id, download.from.table.request=NULL, ...){
      apiResponse <- self$CsvDownloadAsyncStartWithHttpInfo(id, download.from.table.request, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CsvDownloadAsyncStartWithHttpInfo = function(id, download.from.table.request=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      if (!missing(`download.from.table.request`)) {
        body <- `download.from.table.request`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/entity/{id}/table/download/csv/async/start"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "AsyncJobId", loadNamespace("synclient")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    FilePreviewRedirectUrlForRow = function(column.id, id, row.id, version.number, redirect=NULL, ...){
      apiResponse <- self$FilePreviewRedirectUrlForRowWithHttpInfo(column.id, id, row.id, version.number, redirect, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    FilePreviewRedirectUrlForRowWithHttpInfo = function(column.id, id, row.id, version.number, redirect=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`column.id`)) {
        stop("Missing required parameter `column.id`.")
      }

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      if (missing(`row.id`)) {
        stop("Missing required parameter `row.id`.")
      }

      if (missing(`version.number`)) {
        stop("Missing required parameter `version.number`.")
      }

      queryParams['redirect'] <- redirect

      urlPath <- "/entity/{id}/table/column/{columnId}/row/{rowId}/version/{versionNumber}/filepreview"
      if (!missing(`column.id`)) {
        urlPath <- gsub(paste0("\\{", "columnId", "\\}"), URLencode(as.character(`column.id`), reserved = TRUE), urlPath)
      }

      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      if (!missing(`row.id`)) {
        urlPath <- gsub(paste0("\\{", "rowId", "\\}"), URLencode(as.character(`row.id`), reserved = TRUE), urlPath)
      }

      if (!missing(`version.number`)) {
        urlPath <- gsub(paste0("\\{", "versionNumber", "\\}"), URLencode(as.character(`version.number`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "character", loadNamespace("synclient")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    FileRedirectUrlForRow = function(column.id, id, row.id, version.number, redirect=NULL, ...){
      apiResponse <- self$FileRedirectUrlForRowWithHttpInfo(column.id, id, row.id, version.number, redirect, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    FileRedirectUrlForRowWithHttpInfo = function(column.id, id, row.id, version.number, redirect=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`column.id`)) {
        stop("Missing required parameter `column.id`.")
      }

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      if (missing(`row.id`)) {
        stop("Missing required parameter `row.id`.")
      }

      if (missing(`version.number`)) {
        stop("Missing required parameter `version.number`.")
      }

      queryParams['redirect'] <- redirect

      urlPath <- "/entity/{id}/table/column/{columnId}/row/{rowId}/version/{versionNumber}/file"
      if (!missing(`column.id`)) {
        urlPath <- gsub(paste0("\\{", "columnId", "\\}"), URLencode(as.character(`column.id`), reserved = TRUE), urlPath)
      }

      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      if (!missing(`row.id`)) {
        urlPath <- gsub(paste0("\\{", "rowId", "\\}"), URLencode(as.character(`row.id`), reserved = TRUE), urlPath)
      }

      if (!missing(`version.number`)) {
        urlPath <- gsub(paste0("\\{", "versionNumber", "\\}"), URLencode(as.character(`version.number`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "character", loadNamespace("synclient")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetColumnForTable = function(id, ...){
      apiResponse <- self$GetColumnForTableWithHttpInfo(id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetColumnForTableWithHttpInfo = function(id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      urlPath <- "/entity/{id}/column"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "PaginatedColumnModels", loadNamespace("synclient")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetFileHandles = function(id, row.reference.set=NULL, ...){
      apiResponse <- self$GetFileHandlesWithHttpInfo(id, row.reference.set, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetFileHandlesWithHttpInfo = function(id, row.reference.set=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      if (!missing(`row.reference.set`)) {
        body <- `row.reference.set`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/entity/{id}/table/filehandles"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "TableFileHandleResults", loadNamespace("synclient")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetTableTransactionResult = function(async.token, id, ...){
      apiResponse <- self$GetTableTransactionResultWithHttpInfo(async.token, id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetTableTransactionResultWithHttpInfo = function(async.token, id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`async.token`)) {
        stop("Missing required parameter `async.token`.")
      }

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      urlPath <- "/entity/{id}/table/transaction/async/get/{asyncToken}"
      if (!missing(`async.token`)) {
        urlPath <- gsub(paste0("\\{", "asyncToken", "\\}"), URLencode(as.character(`async.token`), reserved = TRUE), urlPath)
      }

      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "TableUpdateTransactionResponse", loadNamespace("synclient")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    QueryAsyncGet = function(async.token, id, ...){
      apiResponse <- self$QueryAsyncGetWithHttpInfo(async.token, id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    QueryAsyncGetWithHttpInfo = function(async.token, id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`async.token`)) {
        stop("Missing required parameter `async.token`.")
      }

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      urlPath <- "/entity/{id}/table/query/async/get/{asyncToken}"
      if (!missing(`async.token`)) {
        urlPath <- gsub(paste0("\\{", "asyncToken", "\\}"), URLencode(as.character(`async.token`), reserved = TRUE), urlPath)
      }

      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "QueryResultBundle", loadNamespace("synclient")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    QueryAsyncStart = function(id, query.bundle.request=NULL, ...){
      apiResponse <- self$QueryAsyncStartWithHttpInfo(id, query.bundle.request, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    QueryAsyncStartWithHttpInfo = function(id, query.bundle.request=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      if (!missing(`query.bundle.request`)) {
        body <- `query.bundle.request`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/entity/{id}/table/query/async/start"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "AsyncJobId", loadNamespace("synclient")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    StartTableTransactionJob = function(id, table.update.transaction.request=NULL, ...){
      apiResponse <- self$StartTableTransactionJobWithHttpInfo(id, table.update.transaction.request, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    StartTableTransactionJobWithHttpInfo = function(id, table.update.transaction.request=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      if (!missing(`table.update.transaction.request`)) {
        body <- `table.update.transaction.request`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/entity/{id}/table/transaction/async/start"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "AsyncJobId", loadNamespace("synclient")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    }
  )
)
